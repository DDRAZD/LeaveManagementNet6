clicking "use individual accounts" in setting up the project creates the Areas section and adds scaffolding of Identity

instead of using mulitple "using" statements in the views for razor sections, you can use _ViewImport.cshtml


------------------------------------
appsettings.json is where the DBContect string will be defined - this replaces the webconfig in .Net 5

-----------------------------------------------------------------

program.cs is old school "main" - it runs every time the app is run;
In the builder, among others, dependancy injection will be defined (same as in Unityconfig in .Net 5)

after the entire build was done, inclusive of the middleware (the code that allows the environment such as the HTTP set up)
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseMigrationsEndPoint();
}
else
{
    app.UseExceptionHandler("/Home/Error");
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}
then there is "app.Run()" that runs the app

------------------------------------------------------------
migrations - after changes run
update-database

to check the data base you go either regularly to SQL Server Management Studio or within Visual studio: view-> SQL Object Explorer
on any table, a quick right click ->view data will show you the table strcuture just like "view first 1000 rows" in SQL Server Management Studio

------------------------------------------------------
when adding the main type of user, add its class in "Data", then make inherit from IdentityUser
this will integate Asp.net.identity automatically and allow you teh build in user management

after that inheritance, you go to the builder (it is in program.cs)-> you update the identity to the type of the user
you replace IdentityUser with your class here (in this case, Employee):

builder.Services.AddDefaultIdentity<Employee>(options => options.SignIn.RequireConfirmedAccount = true)
    .AddEntityFrameworkStores<ApplicationDbContext>();

    in addition, whereever it injects identity (LayoutPartial), you have to update to:
    @inject SignInManager<Employee> SignInManager
@inject UserManager<Employee> UserManager

and for LayoutPartial to find "Employee", in ViewImports, just add the refernece to the data, where "Employee" resides:
@using LeaveManagement.Web.Data

    ---------------------------

In DBContenxt, you need to inherit from IdentityDbContext so it will know the db includes the identity db, and you have to be specific on what user type you will 
be using -> IdentityDbContext<Employee>

--------------------------------
quick best practices and rules:
1) use BaseEntity (abstarct class that cannot be instanciated by its own) to align with DRY -> allows you to inherit to every class, very helpful in data base design-> will include ID -> entity framework is looking for key word 'id'
or looking for the table name (class name) appended infront of Id -> so 'int Id' or 'int LeaveTypeId' (you can continute to use data annotations like you did in .net 5)
2) always have a primary key, for each table
3) add the classes (Tables) in the Data section


do not use "virtual" for lazy loading in EF Core -> just call a reference to the other table without virtual; initially it was not supported in EF Core, 
now virtual is supported but requires you to be consistent accross all calls

In migrations - change onDelete to "Restrict" to avoid deletion of one element cascading and deleting all associcated references in other tables, it is not safe
you do this change manually, before running "update-database". You do this direclty on the migration file. This will obviously be only relevenat in the table
that has a foriegn key

--------------------------------
add controller with EF and views -> tie it to the data model you will be working with (The CRUD one)
as layout page has all the scripts, you can uncheck the scripts box
use layout but _ViewStart will point to the right layout so no need for paths