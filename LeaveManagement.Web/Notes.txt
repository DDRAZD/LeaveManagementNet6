clicking "use individual accounts" in setting up the project creates the Areas section and adds scaffolding of Identity

instead of using mulitple "using" statements in the views for razor sections, you can use _ViewImport.cshtml


------------------------------------
appsettings.json is where the DBContect string will be defined - this replaces the webconfig in .Net 5

-----------------------------------------------------------------

program.cs is old school "main" - it runs every time the app is run;
In the builder, among others, dependancy injection will be defined (same as in Unityconfig in .Net 5)

after the entire build was done, inclusive of the middleware (the code that allows the environment such as the HTTP set up)
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseMigrationsEndPoint();
}
else
{
    app.UseExceptionHandler("/Home/Error");
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}
then there is "app.Run()" that runs the app

------------------------------------------------------------
migrations - after changes run
update-database

to check the data base you go either regularly to SQL Server Management Studio or within Visual studio: view-> SQL Object Explorer
on any table, a quick right click ->view data will show you the table strcuture just like "view first 1000 rows" in SQL Server Management Studio

------------------------------------------------------
when adding the main type of user, add its class in "Data", then make inherit from IdentityUser
this will integate Asp.net.identity automatically and allow you teh build in user management

after that inheritance, you go to the builder (it is in program.cs)-> you update the identity to the type of the user
you replace IdentityUser with your class here (in this case, Employee):

builder.Services.AddDefaultIdentity<Employee>(options => options.SignIn.RequireConfirmedAccount = true)
    .AddEntityFrameworkStores<ApplicationDbContext>();

    in addition, whereever it injects identity (LayoutPartial), you have to update to:
    @inject SignInManager<Employee> SignInManager
@inject UserManager<Employee> UserManager

and for LayoutPartial to find "Employee", in ViewImports, just add the refernece to the data, where "Employee" resides:
@using LeaveManagement.Web.Data

    ---------------------------

In DBContenxt, you need to inherit from IdentityDbContext so it will know the db includes the identity db, and you have to be specific on what user type you will 
be using -> IdentityDbContext<Employee>

--------------------------------
quick best practices and rules:
1) use BaseEntity (abstarct class that cannot be instanciated by its own) to align with DRY -> allows you to inherit to every class, very helpful in data base design-> will include ID -> entity framework is looking for key word 'id'
or looking for the table name (class name) appended infront of Id -> so 'int Id' or 'int LeaveTypeId' (you can continute to use data annotations like you did in .net 5)
2) always have a primary key, for each table
3) add the classes (Tables) in the Data section


do not use "virtual" for lazy loading in EF Core -> just call a reference to the other table without virtual; initially it was not supported in EF Core, 
now virtual is supported but requires you to be consistent accross all calls

In migrations - change onDelete to "Restrict" to avoid deletion of one element cascading and deleting all associcated references in other tables, it is not safe
you do this change manually, before running "update-database". You do this direclty on the migration file. This will obviously be only relevenat in the table
that has a foriegn key

--------------------------------
add controller with EF and views -> tie it to the data model you will be working with (The CRUD one)
as layout page has all the scripts, you can uncheck the scripts box
use layout but _ViewStart will point to the right layout so no need for paths

---------------------
to create the mapping between view model and the models (view model is for UI, model is for the data base), go to the project, right click and go to "manage nuget packages". Seacrch for automapper (it was made by Jimmy Boagard) and install it

also install AutoMapper Dependancy Injection from Jimmy Bogard

once installed, configure it (Similar to the mapping done in .Net 5) -> add folder "Configuration"
add class in it -> MapperConfig.cs; inherit from Profile (coming from automapper)

build a constructor for it:
 public MapperConfig()
        {
            CreateMap<LeaveType, LeaveTypeVM>().ReverseMap(); //allows conversion from model to view model (from data to UI) while "ReverseMap" adds
            //..the reverse conversion from VM back to Data model
            
        }

Then register it in the Program.cs (that replaces all the config file that were in .Net 5 MVC)
add: builder.Services.AddAutoMapper(typeof(MapperConfig));

to leverage the mapper and to begin using each class as a single purpose (data for database, VM from UI), need to add to the controller dependancy injection and 
proprty:
private readonly IMapper mapper;
and add in the constructor
this.mapper = mapper (get the mapper as agrugment of IMapper and add "using Automapper")
and then conversion to view model is simply: "this.mapper.Map<LeaveTypeVM>(what you are converting comes in here)"

--------------------------------
to use js with easy confirms (like "you sure you want to delete"), right click project and "add"  client side libraries: "sweetalert"
if you right click the project and go to "manage client side libraries" you will see the libman.json file listing sweetalert 
the library will be added under "lib" (wwwroot)

add in the view (usually the index) 


@section Scripts {
    <script>
        $(function(){

        });

    </script>
}

as this is expected in the layout page in :
@await RenderSectionAsync("Scripts", required: false)
also, in the layout page, add the script globaly using: ORDER MATTERS; add it after sourcing bootsrrap and jquery; any 3rd party library should come
after the bootstrap and jquery BUT BEFORE your site.js
<script src="~/lib/sweetalert/sweetalert.min.js"></script>

-----------------------------------------------
adding beautified data tables: https://datatables.net/
https://datatables.net/examples/styling/bootstrap5.html

in the layout page, include the needed files AFTER the jquery and the bootstrap
https://cdn.datatables.net/1.12.1/js/jquery.dataTables.min.js
https://cdn.datatables.net/1.12.1/js/dataTables.bootstrap5.min.js

and in the meta:
https://cdn.datatables.net/1.12.1/css/dataTables.bootstrap5.min.css

------------------
font awesome for icons
https://fontawesome.com/
you can browse the different icons in the exmaples and know what to include in your code

right click on project and manage client side libraries (add client side library)
font-awesome (notice the "-")

after instalation, have to add it to the layout file
<link rel="stylesheet" href="~/lib/font-awesome/css/all.css" asp-append-version="true" />
<link rel="stylesheet" href="~/lib/font-awesome/css/fontawesome.css" asp-append-version="true" />

adding icons can be done with <i></i> tags

<i class="fas fa-pencil-alt"></i>

------------------------------------------
<T> allows you to use generics. Not knowing in advance which type would be used. This is useful when building the generic interfaces 
when implementing the repository pattern
" public interface IGenericRepository<T> where T : class"
"Task" are relative to C# asynchornous programming

when inherting the interface, you need again to specify what T is:
public class GenericRepository<T>:IGenericRepository<T> where T : class

Asynchronous tasks are built for more efficiency and performance - hence use them when interacting with the db (context.AddAsync(entity);)
when you are doing Async, you need to await -> add that clause

await context.AddAsync(entity);
await context.SaveChangesAsync();

when you dont know which table it is going to be, you use context.Set<T>() to get to the right table

to update a data base, while not knowing which table it is, you do:
context.Entry(entity).State = Microsoft.EntityFrameworkCore.EntityState.Modified;

entity state is set when we call a method - > EF changes the entity state to the entity; os when we do add, state changes "this might be addition", state 
changed to "addition", so when we do save changes it knows what to do
same for all the rest
for update, we need to tell it that it is a modification (as the update is done outside of the repository so state was not defined as changed), so we change it
with this code:
context.Entry(entity).State = Microsoft.EntityFrameworkCore.EntityState.Modified;

another option is simply to use
context.Update(entity); instead

----------------------------
custom repository
done when you need specific operations beyond CRUD -> you dont want to do it in the controller for proper patterns

after adding repositories, need to register them in program.cs
every time you see IGenericRepository, swap it at run time (dependancy injection) with GenericRepostiory:

builder.Services.AddScoped(typeof(IGenericRepository<>), typeof(GenericRepository<>));
builder.Services.AddScoped<ILeaveTypeRepository, LeaveTypeRepository>();
the difference in syntax is driven by knowing which class you are using in one (leavetype here there is no "T") vs. not knowing (generic is T)

AddScoped = adding an instance and removing the instance once done
AddTransient = keep adding new instances (for example, needing multiple connections to multiple clients)
AddSingelton - add only one -> for example, when creating log files, can only have one 

Those are the 3 ways to add dependancy injection 

this is similar to the Unity.Config file from MVC 5 in which we registered the dependnacy injection-> in .Net Core it is done in Program.cs like above


